{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.immutagen = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      }); // A simple immutable generator emulator that replays history in order to\n      // \"clone\" JavaScript's mutable generators\n\n      exports.default = function (genFun) {\n        var nextFor = function nextFor(history) {\n          return function (input) {\n            var newHist = history.concat([input]),\n                gen = genFun(newHist[0]),\n                _newHist$map$history$ = newHist.map(function (x) {\n              return gen.next(x);\n            })[history.length],\n                value = _newHist$map$history$.value,\n                done = _newHist$map$history$.done;\n            return {\n              value: value,\n              next: done ? undefined : nextFor(newHist),\n              mutable: gen\n            };\n          };\n        };\n\n        return nextFor([]);\n      };\n    }, {}]\n  }, {}, [1])(1);\n});","map":null,"metadata":{},"sourceType":"script"}